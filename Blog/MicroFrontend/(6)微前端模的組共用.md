# 前端也可以搞微服務？！前端最複雜的一種架構

## (五) 模微前端模的組共用

## 問題

隨著微前端應用增加，每一個個體都會打包一些既定的函式庫。跟微服務不同，微前端需要讓客戶承擔流量上的負擔，可能造成額外的流量開支與效能開支，盡可能要去重複應用使用過的。所以像是微服務單純的切分，微前端更要經常煩惱「共用」議題。

### 解決方案

這又不得不提到 module federation ，MF 並不是一個套件，而是一種多模組的管理系統的思維，只是有套件實現了這種思維。

MF 的理念基本上貫穿所有「模組共用」的思維，使用多服務進入點管理多版本的 packages，具備版本識別與切分環境的能力，讓多個組態情境能良好管理各自的環境版本。
如果要細談 MF 可能完全可以開另一個篇章，所以就不打算在微前端篇章提及其實作與原理，還有其相關特性。

目前其實幾乎找不到比起 MF 更完善的其他解決方案，幾乎仰賴大量的基礎建設架構的實作實現，我個人還是建議就用吧。

但也不得不提及，一旦使用了 MF，模組化就會被綁定在 特定的 chunk system ，遷移上變成整個架構的成本。微前端雖然有分散部署的優點，但架構面的部分仰賴一致的規範與協定，如果一致的部分發生變動，那就會根本性的需要大幅度調整。

### Module Federation

很多人提到微前端，反射神經就會想到「Module Federation」，中文稱之「模塊聯邦」，以下簡稱 MF 。但 MF 並不是微前端「必要的」存在，甚至並不是一個 Framework ，它只是一種 bundle 的概念，也只是一個共享程式和共享記憶體的一種手段。

MF 是把各個套件的各個版本分散式存在每一個微服務端點，透過 entry point 的 map 確認是否曾經加載過，當曾經加載過特定版本的 module 之後，就不會重複加載，並且載入同一包被快取的 JavaScript 也可以共享記憶體。而這個機制便是 Webpack5 提供的一個打包機制，也是在微前端去解決「版本管理」、「模塊共享」、「記憶體共享」的關鍵機制，這也是為什麼很多人會把這兩個東西劃上等號。

反過來說，其實不使用 MF 也是能夠處理這樣的機制，但這就牽扯微前端的溝通框架，能否進行這樣的溝通和封裝。通常還是蠻仰賴 Bundle Tool 在預處理，否則處理起來實在是相當囉嗦。

模組共用是微前端在切分時，跟微服務最大的不同。前端是有流量上的消費，每一個客戶端都會造成伺服器一定的負擔，所以像是微服務單純的切分，微前端更要經常煩惱「共用」議題。

這又不得不提到 module federation ，MF 並不是一個套件，而是一種多模組的管理系統的思維，只是有套件實現了這種思維。

MF 的理念基本上貫穿所有「模組共用」的思維，使用多服務進入點管理多版本的 packages，具備版本識別與切分環境的能力，讓多個組態情境能良好管理各自的環境版本。

目前其實幾乎找不到比起 MF 更完善的其他解決方案，幾乎仰賴大量的基礎建設架構的實作實現，我個人還是建議就用吧。

但也不得不提及，一旦使用了 MF，模組化就會被綁定在 特定的 chunk system ，遷移上變成整個架構的成本。微前端雖然有分散部署的優點，但架構面的部分仰賴一致的規範與協定，如果一致的部分發生變動，那就會根本性的需要大幅度調整。
